## Scenario 1: Subscription Impact on Order Frequency

**Objective:** The marketing team wants to know if the subscription program is successful at increasing how often users order. Your task is to compare the ordering behavior of users before and after they subscribe for the first time.

**Task:** For each user who has subscribed, calculate their `avg_days_between_orders_before_sub` and their `avg_days_between_orders_after_sub`. The "before" period is all time leading up to their very first subscription start date. The "after" period begins on their first subscription start date.

The final report should only include users who have at least two orders in both the "before" and "after" periods to allow for a meaningful comparison.

**Expected Output:**

| user_id | avg_days_between_orders_before_sub | avg_days_between_orders_after_sub |
| ------- | ---------------------------------- | --------------------------------- |
| 101     | 19.00                              | 12.50                             |

**Your Solution:**

```sql
-- Step 1: Find the very first subscription date for each user
WITH FirstSubDate AS (
    SELECT
        user_id,
        MIN(start_date) AS first_sub_date
    FROM
        subscription_periods
    WHERE
        start_date IS NOT NULL
    GROUP BY
        user_id
),

-- Step 2: Categorize each order as 'before' or 'after' the first subscription
CategorizedOrders AS (
    SELECT
        uo.user_id,
        uo.order_timestamp,
        CASE
            WHEN uo.order_timestamp < fs.first_sub_date THEN 'before'
            ELSE 'after'
        END AS period
    FROM
        user_orders uo
    JOIN
        FirstSubDate fs ON uo.user_id = fs.user_id
),

-- Step 3: Use LAG() to find the time difference between consecutive orders within each period
OrderGaps AS (
    SELECT
        user_id,
        period,
        -- Calculate the difference in days from the previous order in the same period
        DATEDIFF(order_timestamp, LAG(order_timestamp, 1) OVER (
            PARTITION BY user_id, period
            ORDER BY order_timestamp
        )) AS days_between_orders
    FROM
        CategorizedOrders
),

-- Step 4: Calculate the average gap and order count for each period
PeriodStats AS (
    SELECT
        user_id,
        period,
        AVG(days_between_orders) AS avg_days,
        COUNT(*) AS order_count
    FROM
        OrderGaps
    GROUP BY
        user_id,
        period
)

-- Final Step: Pivot the results and filter for users with enough data
SELECT
    user_id,
    ROUND(MAX(CASE WHEN period = 'before' THEN avg_days END), 2) AS avg_days_between_orders_before_sub,
    ROUND(MAX(CASE WHEN period = 'after' THEN avg_days END), 2) AS avg_days_between_orders_after_sub
FROM
    PeriodStats
GROUP BY
    user_id
HAVING
    -- Filter for users with at least 2 orders in both periods
    MAX(CASE WHEN period = 'before' THEN order_count END) >= 2
    AND MAX(CASE WHEN period = 'after' THEN order_count END) >= 2;
```

## Scenario 2: Churn Analysis - Pre-Cancellation Behavior

**Objective:** To better predict churn, the product team wants to understand user behavior in the 30 days immediately preceding a subscription cancellation.

**Task:** For every subscription that has been cancelled (i.e., has an `end_date`), analyze the user's order activity in the 30-day window before the `end_date`. The report must show the `user_id`, the `subscription_id` that was cancelled, the `total_orders_in_last_30_days`, and the `avg_order_value_in_last_30_days`.

**Expected Output:**

| user_id | subscription_id | total_orders | avg_order_value_in_last_30_days |
| ------- | --------------- | ------------ | ------------------------------- |
| 102     | 2               | 1            | 38.000000                       |
| 104     | 4               | 1            | 33.000000                       |

**Your Solution:**

```sql
SELECT
	sp.user_id,
	sp.subscription_id,
	COUNT(uo.order_id) AS total_orders,
	AVG(uo.order_value) AS avg_order_value_in_last_30_days
FROM
	subscription_periods sp
LEFT JOIN
	user_orders uo ON sp.user_id = uo.user_id
	AND uo.order_timestamp BETWEEN DATE_SUB(sp.end_date, INTERVAL 30 DAY) AND sp.end_date
WHERE
	sp.end_date IS NOT NULL
GROUP BY
	user_id,
	subscription_id;
```

## Scenario 3: Calculating Customer Lifetime Value (CLV) by Subscription Cohort

**Objective:** The finance team needs to understand the total value generated by users based on when they first subscribed. This helps in evaluating the long-term effectiveness of marketing campaigns.

**Task:** Group users into monthly cohorts based on their *first ever* `start_date`. For each cohort, calculate the `total_users` in the cohort and the `avg_clv`. The Customer Lifetime Value (CLV) for a single user is defined as the sum of `order_value` for all orders they placed *after* their first subscription began.

The report should show the `cohort_month` (formatted as 'YYYY-MM'), the `total_users`, and the `avg_clv` for that cohort, rounded to two decimal places.

**Expected Output:**


| cohort_month | total_users | avg_clv |
| ------------ | ----------- | ------- |
| 2023-03      | 2           | 171.00  |
| 2023-04      | 1           | 135.00  |
| 2023-05      | 1           | 125.00  |


**Your Solution:**

```sql
WITH cohorts AS (
	SELECT
		user_id,
		MIN(start_date) AS first_sub_date,
		DATE_FORMAT(MIN(start_date), '%Y-%m') AS cohort_month
	FROM
		subscription_periods
	WHERE
		start_date IS NOT NULL
	GROUP BY
		user_id
),
customer_clv AS (
	SELECT
		uo.user_id,
		SUM(uo.order_value) AS clv
	FROM
		user_orders uo
	JOIN
		cohorts c ON uo.user_id = c.user_id
	WHERE
		uo.order_timestamp >= c.first_sub_date
	GROUP BY
		uo.user_id
)
SELECT
	c.cohort_month,
	COUNT(c.user_id) AS total_users,
	ROUND(AVG(COALESCE(cclv.clv, 0)), 2) AS avg_clv
FROM
	customer_clv cclv
RIGHT JOIN
	cohorts c ON c.user_id = cclv.user_id
GROUP BY
	c.cohort_month;
```
