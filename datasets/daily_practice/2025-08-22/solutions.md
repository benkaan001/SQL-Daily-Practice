## Scenario 1: Calculating Net Revenue per Product

**Objective:** The finance department needs a clear picture of the true revenue generated by each product, accounting for the cost of returns and the benefit of reselling restocked items.

Task: For each product_id, calculate its net_revenue. The calculation should be:

SUM(price of all initial sales) - SUM(price of all returned sales) + SUM(price of all resales of restocked items).

An "initial sale" is any 'SALE' event. A "returned sale" is an initial sale that is followed by a `RETURN_PROCESSED` event. A "resale" is a 'SALE' event that happens *after* a `RETURN_PROCESSED` event for the same `item_sku`.

**Expected Output:**

| product_id | net_revenue |
| ---------- | ----------- |
| 101        | 50          |
| 102        | 145         |
| 103        | 120         |
| 104        | 180         |

**Your Solution:**

```sql
-- Step 1: Categorize every single sale event
WITH CategorizedSales AS (
    SELECT
        ile.product_id,
        ile.item_sku,
        JSON_UNQUOTE(JSON_EXTRACT(ile.details, '$.price')) AS price,
        -- A "resale" is a SALE that happens after a RETURN_PROCESSED event for the same SKU
        CASE
            WHEN EXISTS (
                SELECT 1 FROM item_lifecycle_events sub
                WHERE sub.item_sku = ile.item_sku
                  AND sub.event_type = 'RETURN_PROCESSED'
                  AND sub.event_timestamp < ile.event_timestamp
            ) THEN 'resale'
            ELSE 'initial_sale'
        END AS sale_type,
        -- A sale is "returned" if it is followed by a RETURN_PROCESSED event for the same SKU
        CASE
            WHEN EXISTS (
                SELECT 1 FROM item_lifecycle_events sub
                WHERE sub.item_sku = ile.item_sku
                  AND sub.event_type = 'RETURN_PROCESSED'
                  AND sub.event_timestamp > ile.event_timestamp
            ) THEN TRUE
            ELSE FALSE
        END AS was_returned
    FROM
        item_lifecycle_events ile
    WHERE
        ile.event_type = 'SALE'
),

-- Step 2: Aggregate the values based on the categories
AggregatedRevenue AS (
    SELECT
        product_id,
        -- Sum of all initial sales
        SUM(CASE WHEN sale_type = 'initial_sale' THEN price ELSE 0 END) AS total_initial_sales,
        -- Sum of only the initial sales that were returned
        SUM(CASE WHEN sale_type = 'initial_sale' AND was_returned = TRUE THEN price ELSE 0 END) AS total_returned_sales,
        -- Sum of all resales
        SUM(CASE WHEN sale_type = 'resale' THEN price ELSE 0 END) AS total_resales
    FROM
        CategorizedSales
    GROUP BY
        product_id
)

-- Final Step: Apply the formula from the prompt
SELECT
    product_id,
    (total_initial_sales - total_returned_sales + total_resales) AS net_revenue
FROM
    AggregatedRevenue
ORDER BY
    product_id;
```

## Scenario 2: Return Rate by Reason and Time-to-Return

**Objective:** As a product analyst, you want to understand *why* items are returned and *how quickly* customers decide to return them.

**Task:** For each distinct return `reason`, calculate:

1. `return_count`: The total number of items returned for this reason.
2. `avg_days_to_return`: The average number of days between the initial 'SALE' event and the 'RETURN_REQUEST' event for items returned for this reason.

The final report should be ordered by `return_count` in descending order.

**Expected Output:**

| reason         | return_count | avg_days_to_return |
| -------------- | ------------ | ------------------ |
| "Wrong Size"   | 2            | 3.50               |
| "Defective"    | 2            | 3.50               |
| "Changed Mind" | 2            | 4.00               |

**Your Solution:**

```sql
WITH transactions AS (
    SELECT
    	JSON_EXTRACT(returns.details, '$.reason') AS reason,
        DATEDIFF(returns.event_timestamp, sales.event_timestamp) AS days_to_return
    FROM
        item_lifecycle_events sales
    JOIN
        item_lifecycle_events returns
        ON sales.item_sku = returns.item_sku
        AND sales.order_id = returns.order_id
    WHERE
        sales.event_type = 'SALE'
        AND returns.event_type = 'RETURN_REQUEST'
)
SELECT
    reason,
    COUNT(*) AS return_count,
    ROUND(AVG(days_to_return), 2) AS avg_days_to_return
FROM
    transactions
GROUP BY
    reason
ORDER BY
    return_count DESC;
```

## Scenario 3: Identifying "Zombie" Returns

**Objective:** The logistics team is concerned about "zombie" returnsâ€”items where a return was requested but the item never made it back to the warehouse to be processed.

**Task:** Write a query to identify all `item_sku`s that have a `RETURN_REQUEST` event but do not have a subsequent `RETURN_PROCESSED` event. For these items, calculate the number of `days_since_request` as of '2023-12-01'.

The final report should show the `item_sku`, the `product_id`, the `order_id` of the return, and the `days_since_request`.

**Expected Output:**

| item_sku  | product_id | order_id | days_since_request |
| --------- | ---------- | -------- | ------------------ |
| SKU-E-001 | 102        | ORD-005  | 22                 |

**Your Solution:**

```sql
WITH returns AS (
	SELECT
		item_sku,
		product_id,
		order_id,
		event_timestamp AS return_request_timestamp,
		event_type,
		LEAD(event_type, 1) OVER (PARTITION BY product_id, item_sku ORDER BY event_timestamp) AS next_event
	FROM
		item_lifecycle_events
	WHERE
		event_type LIKE '%RETURN%'
)
SELECT
	item_sku,
	product_id,
	order_id,
	DATEDIFF(DATE('2023-12-01'), return_request_timestamp) AS days_since_request
FROM
	returns
WHERE
	event_type = 'RETURN_REQUEST'
	AND next_event IS NULL;
```
